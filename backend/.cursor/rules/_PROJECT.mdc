---
alwaysApply: true
---

## 1. Project Purpose
Turn any article URL into a clean, downloadable podcast episode in minutes.  The backend exposes an API to submit jobs and a worker service to process them asynchronously.

## 2. Repository Layout
```
backend/
├── infra/            # AWS CDK (TypeScript) – infrastructure-as-code
│   ├── main.ts       # CDK app entry
│   └── stacks/       # Stacks (BackendStack.ts)
├── services/         # Fargate micro-services (npm workspaces)
│   ├── api/          # Express API (TypeScript)
│   │   ├── src/
│   │   └── Dockerfile
│   └── worker/       # Async worker (TypeScript + ffmpeg)
│       ├── src/
│       └── Dockerfile
├── scripts/          # Helper CLI scripts (dev.sh)
├── tsconfig.json     # Root tsconfig for infra only
└── tsconfig.base.json# Shared compiler defaults (not used inside Docker
```

Key points:
* **Each service is an isolated npm workspace** with its own `package.json`, `tsconfig.json`, `Dockerfile` & build pipeline.
* **Infrastructure code lives exclusively in `infra/`** and should never import application code.

## 3. Build & Run Commands
Dockerfiles install *all* deps, run `npm run build`, then prune dev-deps for a slim runtime layer.

## 4. AWS Architecture
* **ECS Fargate Cluster** – `pocket-pod-cluster`
* **API Service** – 1 × 256 CPU / 512 MiB behind an ALB (port 80 ➜ 3000)
* **Worker Service** – 0-N × 1 vCPU / 2 GiB tasks processing Redis jobs
* **DynamoDB** – table `pocket-pod-jobs` (`pk=userId`, `sk=jobId`, GSI `StatusIndex`)
* **Redis (ElastiCache)** – single-node `cache.t3.micro` (Streams for job queue)
* **S3** – bucket `pocket-pod-episodes-*` for final `.mp3` assets
* **IAM** – least-privilege roles: API ⇄ DynamoDB, Worker ⇄ DynamoDB/S3/Polly

> NOTE   All destroy-policies & auto-delete objects are *development-only* settings – review before production.

## 5. Coding Conventions
1. **Language/Target**   TypeScript 5+, `target=ES2022`, `moduleResolution=NodeNext`.
2. **Imports**           Prefer ESM style; enable `esModuleInterop` where default import is needed.
3. **Strictness**        `strict`, `noImplicitAny`, `strictNullChecks` ON.
4. **Directory Aliases** Avoid ts-path aliases across workspace boundaries – reference by relative import only.
5. **Testing**           (To-be-added) – Jest or Vitest per service.
6. **CI/CD**             GitHub Actions: lint → test → `cdk synth` → `cdk deploy` via OIDC.

## 6. Edge Cases & Non-Goals
* **Lambda** is intentionally *not* used – stick to Fargate containers.
* **Large binaries** (ffmpeg) belong *only* in the Worker image.
* **Public access to S3 objects** should be via **pre-signed URLs** generated by the API (not bucket policies).

### When generating code, Cursor MUST:
1. Keep service isolation – never import from `services/api` inside `services/worker` (and vice-versa).
2. Add new services **inside `services/`** as npm workspaces with their own `tsconfig.json` & Dockerfile.
3. Update CDK stack to wire resources (port mappings, env vars, IAM) when new services/assets are introduced.
4. Maintain the existing build script (`scripts/dev.sh`) when extending functionality.

